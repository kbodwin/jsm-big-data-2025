<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>outline_draft – JSM 2025: Large Local Data Course</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-25e1e507b8be7f2900acee399cb139aa.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">JSM 2025: Large Local Data Course</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../bio.html"> 
<span class="menu-text">Presenters</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-slides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Slides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-slides">    
        <li>
    <a class="dropdown-item" href="../materials/slides/00-setup-intro.html">
 <span class="dropdown-text">Introductions; Setup and Install</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../materials/slides/01-slowdowns-solutions.html">
 <span class="dropdown-text">Identifying Slowdowns and Solutions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../materials/slides/02-datatable.html">
 <span class="dropdown-text">Using the data.table package</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../materials/slides/03-arrow.html">
 <span class="dropdown-text">Using arrow and duckdb</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../materials/slides/04-datatable.qmd">
 <span class="dropdown-text">Workflow: Putting it together</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-activities" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Activities</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-activities">    
        <li>
    <a class="dropdown-item" href="../materials/activities/01-practice-data.html">
 <span class="dropdown-text">Get started with your data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../materials/activities/02-practice-datatable.html">
 <span class="dropdown-text">Practice using data.table</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../materials/activities/practice-arrow.qmd">
 <span class="dropdown-text">Practice using arrow and duckdb</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../materials/activities/practice-workflow.qmd">
 <span class="dropdown-text">Put it all together</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kbodwin/jsm-large-data-2025"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#course-outline" id="toc-course-outline" class="nav-link active" data-scroll-target="#course-outline">Course Outline</a>
  <ul class="collapse">
  <li><a href="#unit-one-defining-the-problem" id="toc-unit-one-defining-the-problem" class="nav-link" data-scroll-target="#unit-one-defining-the-problem">Unit One: Defining the problem</a></li>
  <li><a href="#unit-two-handle-it-in-r-with-data.table" id="toc-unit-two-handle-it-in-r-with-data.table" class="nav-link" data-scroll-target="#unit-two-handle-it-in-r-with-data.table">Unit Two: Handle it in R with data.table</a></li>
  <li><a href="#unit-three-handle-it-in-a-local-database-with-arrow-and-duckdb" id="toc-unit-three-handle-it-in-a-local-database-with-arrow-and-duckdb" class="nav-link" data-scroll-target="#unit-three-handle-it-in-a-local-database-with-arrow-and-duckdb">Unit Three: Handle it in a local “database” with arrow and duckdb</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/kbodwin/jsm-big-data-2025/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="course-outline" class="level1">
<h1>Course Outline</h1>
<section id="unit-one-defining-the-problem" class="level2">
<h2 class="anchored" data-anchor-id="unit-one-defining-the-problem">Unit One: Defining the problem</h2>
<ul>
<li><p>How big is my data? Long, wide or both?</p></li>
<li><p>How big is my analysis? Big because many groups? Big because looping? Big because matrix computation?</p></li>
<li><p>How often will I repeat my analysis? By myself as I refine it? In production?</p></li>
<li><p>How to choose a tool? -&gt; You have one dataset. It can read into R, but tasks are slow:</p></li>
<li><p>grouping and summarizing, esp over a variable with many cats</p></li>
<li><p>mapping through a column, e.g to string process or custom function</p></li>
<li><p>computing lags, sliders, etc.</p></li>
<li><p>making many new columns</p></li>
</ul>
<p>What’s my slowdown? -&gt; profvis</p>
<p>Persona: Survey research</p>
<p>-&gt; You have one dataset. It is too large to read into R.</p>
<p>Persona: Biological genetic data</p>
<p>What’s my slowdown? -&gt; read a few lines, develop your pipeline, profvis</p>
<p>-&gt; You have many datasets. At least one is too large to read into R. Joining and subsetting is slow.</p>
<p>Persona: Customer data</p>
<ul>
<li>What makes some code faster than others?</li>
<li>Efficiency of <strong>pipeline</strong>: filter before mutate.</li>
<li>Efficiency of <strong>algorithm</strong>: think matrix order</li>
<li>Efficiency of <strong>memory handling</strong>: careful C allocations</li>
<li>Efficiency of <strong>interpreting</strong> or <strong>compiling</strong></li>
<li>Efficiency of <strong>data storage structure</strong></li>
<li>Smart saving of <strong>intermediate objects</strong>.</li>
</ul>
<p>x: data size y: number of repeated operations</p>
<p>1,1: any 1,2: data table. [write more efficient code] 2,1: parquet &amp; arrow [use better storage formats] 2,2: duckdb &amp; arrow [run in SQL not R]</p>
<p>higher x -&gt; cloud database higher y -&gt; bigger machine/parallelize across machines/whatever</p>
</section>
<section id="unit-two-handle-it-in-r-with-data.table" class="level2">
<h2 class="anchored" data-anchor-id="unit-two-handle-it-in-r-with-data.table">Unit Two: Handle it in R with data.table</h2>
</section>
<section id="unit-three-handle-it-in-a-local-database-with-arrow-and-duckdb" class="level2">
<h2 class="anchored" data-anchor-id="unit-three-handle-it-in-a-local-database-with-arrow-and-duckdb">Unit Three: Handle it in a local “database” with arrow and duckdb</h2>
<p>small: &lt; 1000 or something, everything is split second</p>
<p>medium: 100000 or so, and/or many categories, can read into R but analysis is slow</p>
<p>large: parquet can store on local machine</p>
<p>massive: too big for local machine</p>
<p>Questions for Tyson/Jon: - Easy way to convert csv to parquet w/o reading into R?<br>
- Column and row size; handled differently in R? In parquet? In a db?</p>
<p>Title of course Storing, Importing, Managing, and Analyzing Large Data Locally with R Instructor 1 Kelly Bodwin Instructor 1 Email kbodwin@calpoly.edu Instructor 2 Tyson Barrett Instructor 2 Email tyson.barrett@usu.edu Instructor 3 Jonathan Keane Instructor 3 Email jkeane@gmail.com Length of Course<br>
Full-day (7.5 contact hours) Course Description It is increasingly common in academic and professional settings to encounter datasets large enough to exceed the capabilities of standard data processing tools, yet small enough to be stored on local computers. Recent articles even claim that “the era of big data is over” and that data analysts and researchers should “think small, develop locally, ship joyfully.” Such “medium” dataests are instrumental in measuring, tracking, and recording a wide array of phenomena across disciplines such as human behavior, animal studies, geology, economics, and astronomy. In this workshop, we will present modern techniques for handling large local data in R using a tidy data pipeline, encompassing stages from data storage and importing to cleaning, analysis, and exporting data and analyses. Specifically, we will teach a combination of tools from the data.table, arrow, and duckDB packages, with a focus on parquet data files for storage and transfer. By the end of the workshop, participants will understand how to integrate these tools to establish a legible, reproducible, efficient, and high-performance workflow.<br>
Course Outline The following outline shows our planned approach to managing and analyzing large data locally in R. Our target audience are individuals in academic or professional data analysis positions, who work regularly with datasets that are manageable in terms of local storage but pose significant challenges in processing and cleaning due to their size and complexity.</p>
<p>Unit 1: Identifying slowdowns in your local data process (Bodwin; 1 hour)</p>
<p>1.1 Finding the problem:<br>
- User-friendly code timing with tictoc - Comparing runtimes with atime - Code profiling with profvis</p>
<p>1.2 Categories of bottlenecks - Common scenarios for repeated runs of code sections - Speed impact from order-of-operations in data wrangling - Fast vs.&nbsp;slow types of dataset operations in R</p>
<p>1.3 Activity: Code-along demo - Walkthrough of common data structures and tasks that could benefit from modern large-data tools</p>
<p>Unit 2: In-Memory data wrangling with data.table (Barrett; 2 hours)</p>
<p>2.1 Introduction - Basic syntax and structure of data.table - Speed comparison for common simple data tasks - High-level, user-friendly intuition for data.table’s “under the hood” parallel processing and C optimization</p>
<p>2.2 Data wrangling tools - Filtering, summarizing, grouping, and mutating data - Sophisticated data processing with the set* functions.</p>
<p>2.3 Activity: Code-Along - Real-data examples of data.table use for processing and analyzing data.</p>
<p>2.4 Reference semantics - Speed and memory gains from modify-by-reference - Effects and side-effects of modify-by-reference - data.table syntax for fast no-copy data transformation</p>
<p>2.5 Helper packages - Brief highlight of dtplyr and tidyfast as syntactical wrappers to data.table - Storing and reading data.table objects with parquet.</p>
<p>2.6 Activity: Case Study - Learners work through a guided but incomplete real-data analysis.</p>
<p>Unit 3: Storing, Reading, and Converting data with arrow, parquet, and duckdb (Keane 2 hours, Bodwin/Barrett 1 hour)</p>
<p>3.1 Introduction to Arrow and Parquet - Intro to history and development of Arrow - Basic Arrow infrastructure and syntax - Discussion of the interchange problem - Using arrow reader and nanoparquet for efficient dataset storage and input. - Discussion of the Parquet structure, including column orientation and its benefits</p>
<p>3.2 Activity: Code-Along - Data analysis with Arrow.</p>
<p>3.3 Introduction to DuckDB - Introduction to duckDB and the local database model. - Basic duckDB syntax. - Data processing and analysis in duckDB - Helper packages such as duckplyr. - Working with duckDB and parquet files simultaneously.</p>
<p>3.4 Activity: Code-Along - Data analysis with duckDB.</p>
<p>3.5 Comparison of tools - Similarities and trade-offs of arrow, duckDB, and data.table. - Options for dplyr syntax in all three packages.</p>
<p>3.6 Activity: Case Study - Goals: Compare, contrast, and benchmark - Learners repeat a data analysis task three times, using each of the three tools. - Learners benchmark the speed of each step of the task in the three implementations. - Discussion and reflection on learner-preferred syntax and usage.</p>
<p>Unit 4: Putting it together: a workflow for efficient data manipulation (Bodwin/Barrett 1.5 hours)</p>
<p>4.1 Showcase: A tidy pipeline using these modern, efficient tools - Import/export: fread, parquet with arrow/duckDB - Tidy: dtplyr, duckplyr, arrow - Transform: dtplyr, duckplyr, arrow</p>
<p>4.2 Decisions and Guidelines - When to choose fread with csv versus parquet conversion. - Pros and cons of the local database structure versus local raw data files. - Specific data sizes, formats, and computations that are best suited to each tool.</p>
<p>4.3 Activity: Final Case Study - Learners take ownership of a case study of real world large data, writing their own code with a large dataset from start to finish with instructor support Learning Objectives Diagnosing and Benchmarking: - Incorporate time checks into a data analysis workflow to identify slowdowns. - Recognize workflow sections that are likely to be re-run - Design data pipeline steps to isolate and improve bottlenecks</p>
<p>Syntax: - Write basic data analysis code in data.table - Write basic data analysis code in arrow - Write basic data analysis code in duckDB - Write dplyr syntax code with dtplyr and duckplyr</p>
<p>Concepts and Ideas: - Recognize grouping and summarizing operations that will benefit from the data.table implementation - Understand the modify-by-reference approach - Understand the benefits of parquet’s column orientation storage - Know the difference between a collection of local files and a local database.</p>
<p>Workflow: - Read csv data with fread and parquet format data with arrow - Set up and read/write data in a local duckDB database - Smoothly switch between major large data tools within a single data processing and analyzing pipeline. Instructor(s) Background Dr.&nbsp;Kelly Bodwin is an educator with over a decade of experience of teaching statistics and data science with R. She has co-authored multiple R packages, including flair and tidyclust, and she is currently a consultant on an NSF Grant building infrastructure for the data.table package. Her published applied research frequently involves manipulating large, in-memory data. Examples include: performing large matrix computations on high-dimensional GWAS (genome-wide association studies) data; constructing temporal social networks at hundreds of time checkpoints for organizational membership data; and summarizing biodiversity metrics grouped over exhaustive permutations of taxa level organism counts and experimental conditions. Above all, Dr.&nbsp;Bodwin’s educational goal is to lower barriers to entry for beginner and intermediate R users to benefit from modern tools and enable more efficient and effective data workflows.</p>
<p>Dr.&nbsp;Tyson Barrett is a researcher and an applied statistician at Highmark Health and Utah State University. He has over 15 years of R package development and programming experience, including maintaining data.table (with over 600,000 monthly downloads) and 3 other published R packages. He is currently a consultant on an NSF Grant building infrastructure for the data.table package. In his research work, he regularly works with large datasets with millions of rows and hundreds of columns. He and his team use data.table, arrow, and duckDB daily to manage and analyze their data to efficiently and quickly communicate insights with stakeholders.</p>
<p>Dr.&nbsp;Jonathan Keane is an engineering leader at Posit, PBC with a background in data science and social science. They have been building data tooling for 15 years, including both R and Python data tools for scientific and data science computing. They are a member of the PMC for Apache Arrow, a maintainer of the Apache Arrow package, and the author of dittodb. They have also worked as a data scientist in a number of different industries (identify verification and fraud, market research, call centers, and social justice among other areas) using a wide range of tools to analyze, model, and use data at large enterprise scales. On top of building data tooling, they have a passion for teaching data scientists and others how to use data and tools to do their work and inform their decisions.</p>
<p>Additional Comments Learners should bring a working laptop with an installation of R 4.0+ and a recent (2023 or later) installation of RStudio or Positron. Learners should ensure that their laptop has admin permission for installation of new R packages.</p>
<p>A beginner-intermediate level of working knowledge in R with the tidyverse is assumed; at approximately the level of Chapters 1-8 in Wickham’s R for Data Science (2e).</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/kbodwin\.github\.io\/jsm-big-data-2025");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2025, Kelly Bodwin, Tyson Barrett &amp; Jonathan Keane</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/kbodwin/jsm-big-data-2025/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This page is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>